import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Project root: A:\NCKH_Web\PetAI
const projectRoot = path.resolve(__dirname, '../../../');

// Input CSV: PetAI/ai/data/metadata.csv
const inputFile = path.join(
    projectRoot,
    'ai',
    'data',
    'metadata.csv'
);

// Output JSON: PetAI/frontend/src/data/pets_data.json
const outputFile = path.join(
    projectRoot,
    'frontend',
    'src',
    'data',
    'pets_data.json'
);


// Ensure output directory exists
const outputDir = path.dirname(outputFile);
if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
}

fs.readFile(inputFile, 'utf8', (err, data) => {
    if (err) {
        console.error('Error reading file:', err);
        return;
    }

    // Reuse the same parsing logic
    const parseCSV = (text) => {
        const result = [];
        let row = [];
        let inQuote = false;
        let currentCell = '';

        for (let i = 0; i < text.length; i++) {
            const char = text[i];
            const nextChar = text[i + 1];

            if (char === '"') {
                if (inQuote && nextChar === '"') {
                    currentCell += '"';
                    i++; // skip next quote
                } else {
                    inQuote = !inQuote;
                }
            } else if (char === ',' && !inQuote) {
                row.push(currentCell);
                currentCell = '';
            } else if ((char === '\r' || char === '\n') && !inQuote) {
                if (char === '\r' && nextChar === '\n') i++;
                row.push(currentCell);
                if (row.length > 1 || row[0] !== '') { // Skip empty rows
                    result.push(row);
                }
                row = [];
                currentCell = '';
            } else {
                currentCell += char;
            }
        }
        if (row.length > 0) result.push(row);
        return result;
    };

    const rows = parseCSV(data);

    // Config based on the NEW CSV structure generated by vibe_csv.py
    // Row 0: Header
    // Indices:
    // 0: STT
    // 1: type
    // 2: tên giống loài (Name)
    // 3: tuổi thọ trung bình (Lifespan)
    // 4: cách chăm (Care)
    // 5: giá có giấy tờ (Price Paper)
    // 6: giá không giấy tờ (Price No Paper)
    // 7: giá quốc tế (Price Intl)
    // 8: score_energy
    // 9: score_space
    // 10: score_grooming
    // 11: score_kid_friendly
    // 12: is_cat

    const dataRows = rows.slice(1); // Skip only the first header row

    const pets = dataRows.map(row => {
        // Safe access
        const get = (idx) => (row[idx] || '').trim();

        const name = get(2); // Name is now index 2
        if (!name) return null; // Skip empty rows

        const slug = name.toLowerCase().trim().replace(/\s+/g, '_');
        const type = get(1); // Explicit Type
        const lifespan = get(3);
        const care = get(4);

        // Prices
        const pricePaper = get(5);
        const priceNoPaper = get(6);
        const priceInternational = get(7);

        // Scores (Direct parse)
        const scoreEnergy = parseInt(get(8)) || 3;
        const scoreSpace = parseInt(get(9)) || 3;
        const scoreGrooming = parseInt(get(10)) || 3;
        const scoreKid = parseInt(get(11)) || 3; // Default Neural

        // is_cat check (explicit)
        const isCat = parseInt(get(12)) === 1;

        // Determine Size Category based on Space Score (1-5)
        // 1-2: Nhỏ, 3: Trung bình, 4-5: Lớn
        let size = 'Trung bình';
        if (scoreSpace <= 2) size = 'Nhỏ';
        if (scoreSpace >= 4) size = 'Lớn';

        // Extract numeric price for filtering (Approximation)
        const parsePrice = (str) => {
            const numbers = str.match(/(\d+)/g);
            if (!numbers) return 0;
            return parseInt(numbers[0]);
        };

        const priceMin = parsePrice(pricePaper);

        const allPrices = [pricePaper, priceNoPaper, priceInternational].join(' ');
        const priceMatches = allPrices.match(/(\d+)/g);
        let realMin = 0, realMax = 100;
        if (priceMatches) {
            const nums = priceMatches.map(n => parseInt(n));
            realMin = Math.min(...nums);
            realMax = Math.max(...nums);
        }

        return {
            id: slug,
            name: name.replace(/_/g, ' '),
            type: type, // Use explicit type from CSV
            lifespan: lifespan,
            care_instruction: care,
            price: {
                paper: pricePaper,
                no_paper: priceNoPaper,
                international: priceInternational
            },
            priceMin: realMin,
            priceMax: realMax,
            size: size,
            scores: {
                energy: scoreEnergy,
                space: scoreSpace,
                grooming: scoreGrooming,
                kid_friendly: scoreKid
            },
            image_path: `/assets/avatar/${slug}.jpg`
        };
    }).filter(p => p !== null);

    const jsonContent = JSON.stringify(pets, null, 2);

    fs.writeFile(outputFile, jsonContent, 'utf8', (err) => {
        if (err) {
            console.error('Error writing JSON:', err);
        } else {
            console.log(`Successfully converted ${pets.length} pets to ${outputFile}`);
        }
    });
});
